<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Efficient Sum and Mean · LossFunctions.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/><link href="../../assets/style.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../../index.html"><img class="logo" src="../../assets/logo.png" alt="LossFunctions.jl logo"/></a><h1>LossFunctions.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><span class="toctext">Introduction</span><ul><li><a class="toctext" href="../../introduction/gettingstarted/">Getting Started</a></li><li><a class="toctext" href="../../introduction/motivation/">Background and Motivation</a></li></ul></li><li><span class="toctext">User&#39;s Guide</span><ul><li><a class="toctext" href="../interface/">Working with Losses</a></li><li class="current"><a class="toctext" href>Efficient Sum and Mean</a><ul class="internal"><li><a class="toctext" href="#Average-Modes-1">Average Modes</a></li><li><a class="toctext" href="#Unweighted-Sum-and-Mean-1">Unweighted Sum and Mean</a></li><li><a class="toctext" href="#Sum-and-Mean-per-Observation-1">Sum and Mean per Observation</a></li><li><a class="toctext" href="#Weighted-Sum-and-Mean-1">Weighted Sum and Mean</a></li></ul></li></ul></li><li><span class="toctext">Available Losses</span><ul><li><a class="toctext" href="../../losses/distance/">Distance-based Losses</a></li><li><a class="toctext" href="../../losses/margin/">Margin-based Losses</a></li></ul></li><li><span class="toctext">Advances Topics</span><ul><li><a class="toctext" href="../../advanced/extend/">Altering existing Losses</a></li><li><a class="toctext" href="../../advanced/developer/">Developer Documentation</a></li></ul></li><li><a class="toctext" href="../../acknowledgements/">Acknowledgements</a></li><li><a class="toctext" href="../../LICENSE/">LICENSE</a></li></ul></nav><article id="docs"><header><nav><ul><li>User&#39;s Guide</li><li><a href>Efficient Sum and Mean</a></li></ul><a class="edit-page" href="https://github.com/JuliaML/LossFunctions.jl/blob/master/docs/src/user/aggregate.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Efficient Sum and Mean</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Efficient-Sum-and-Mean-1" href="#Efficient-Sum-and-Mean-1">Efficient Sum and Mean</a></h1><p>In many situations we are not really that interested in the individual loss values (or derivatives) of each observation, but the sum or mean of them; be it weighted or unweighted. For example, by computing the unweighted mean of the loss for our training set, we would effectively compute what is known as the empirical risk. This is usually the quantity (or an important part of it) that we are interesting in minimizing.</p><p>When we say &quot;weighted&quot; or &quot;unweighted&quot;, we are referring to whether we are explicitly specifying the influence of individual observations on the result. &quot;Weighing&quot; an observation is achieved by multiplying its value with some number (i.e. the &quot;weight&quot; of that observation). As a consequence that weighted observation will have a stronger or weaker influence on the result. In order to weigh an observation we have to know which array dimension (if there are more than one) denotes the observations. On the other hand, for computing an unweighted result we don&#39;t actually need to know anything about the meaning of the array dimensions, as long as the <code>targets</code> and the <code>outputs</code> are of compatible shape and size.</p><p>The naive way to compute such an unweighted reduction, would be to call <code>mean</code> or <code>sum</code> on the result of the element-wise operation. The following code snipped show an example of that. We say &quot;naive&quot;, because it will not give us an acceptable performance.</p><pre><code class="language-julia-repl">julia&gt; value(L1DistLoss(), [1.,2,3], [2,5,-2])
3-element Array{Float64,1}:
 1.0
 3.0
 5.0

julia&gt; sum(value(L1DistLoss(), [1.,2,3], [2,5,-2])) # WARNING: Bad code
9.0</code></pre><p>This works as expected, but there is a price for it. Before the sum can be computed, <a href="#LearnBase.value-Tuple{Loss,AbstractArray,AbstractArray,LossFunctions.AverageMode}"><code>value</code></a> will allocate a temporary array and fill it with the element-wise results. After that, <code>sum</code> will iterate over this temporary array and accumulate the values accordingly. Bottom line: we allocate temporary memory that we don&#39;t need in the end and could avoid.</p><p>For that reason we provide special methods that compute the common accumulations efficiently without allocating temporary arrays. These methods can be invoked using an additional parameter which specifies how the values should be accumulated / averaged. The type of this parameter has to be a subtype of <code>AverageMode</code>.</p><h2><a class="nav-anchor" id="Average-Modes-1" href="#Average-Modes-1">Average Modes</a></h2><p>Before we discuss these memory-efficient methods, let us briefly introduce the available average mode types. We provide a number of different averages modes, all of which are contained within the namespace <code>AvgMode</code>. An instance of such type can then be used as additional parameter to <a href="#LearnBase.value-Tuple{Loss,AbstractArray,AbstractArray,LossFunctions.AverageMode}"><code>value</code></a>, <a href="#LearnBase.deriv-Tuple{Loss,AbstractArray,AbstractArray,LossFunctions.AverageMode}"><code>deriv</code></a>, and <a href="#LearnBase.deriv2-Tuple{Loss,AbstractArray,AbstractArray,LossFunctions.AverageMode}"><code>deriv2</code></a>, as we will see further down.</p><p>It follows a list of available average modes. Each of which with a short description of what their effect would be when used as an additional parameter to the functions mentioned above.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LossFunctions.AvgMode.None" href="#LossFunctions.AvgMode.None"><code>LossFunctions.AvgMode.None</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">AvgMode.None()</code></pre><p>Opt-out of aggregation. This is usually the default value. Using <code>None</code> will cause the element-wise results to be returned.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaML/LossFunctions.jl/blob/64d4c4e16e19698a1e877db6ecaf7bdbe21de250/src/averagemode.jl#L17-L22">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LossFunctions.AvgMode.Sum" href="#LossFunctions.AvgMode.Sum"><code>LossFunctions.AvgMode.Sum</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">AvgMode.Sum()</code></pre><p>Causes the method to return the unweighted sum of the elements instead of the individual elements. Can be used in combination with <code>ObsDim</code>, in which case a vector will be returned containing the sum for each observation (useful mainly for multivariable regression).</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaML/LossFunctions.jl/blob/64d4c4e16e19698a1e877db6ecaf7bdbe21de250/src/averagemode.jl#L25-L33">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LossFunctions.AvgMode.Mean" href="#LossFunctions.AvgMode.Mean"><code>LossFunctions.AvgMode.Mean</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">AvgMode.Mean()</code></pre><p>Causes the method to return the unweighted mean of the elements instead of the individual elements. Can be used in combination with <code>ObsDim</code>, in which case a vector will be returned containing the mean for each observation (useful mainly for multivariable regression).</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaML/LossFunctions.jl/blob/64d4c4e16e19698a1e877db6ecaf7bdbe21de250/src/averagemode.jl#L36-L44">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LossFunctions.AvgMode.WeightedSum" href="#LossFunctions.AvgMode.WeightedSum"><code>LossFunctions.AvgMode.WeightedSum</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">AvgMode.WeightedSum(weights; [normalize = false])</code></pre><p>Causes the method to return the weighted sum of all observations. The variable <code>weights</code> has to be a vector of the same length as the number of observations. If <code>normalize = true</code>, the values of the weight vector will be normalized in such as way that they sum to one.</p><p><strong>Arguments</strong></p><ul><li><code>weights::AbstractVector</code>: Vector of weight values that can be used to give certain observations a stronger influence on the sum.</li></ul><ul><li><p><code>normalize::Bool</code>: Boolean that specifies if the weight vector should be transformed in such a way that it sums to one (i.e. normalized). This will not mutate the weight vector but instead happen on the fly during the accumulation.</p><p>Defaults to <code>false</code>. Setting it to <code>true</code> only really makes sense in multivalue-regression, otherwise the result will be the same as for <a href="#LossFunctions.AvgMode.WeightedMean"><code>WeightedMean</code></a>.</p></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; AvgMode.WeightedSum([1,1,2]); # 3 observations

julia&gt; AvgMode.WeightedSum([1,1,2], normalize = true);</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaML/LossFunctions.jl/blob/64d4c4e16e19698a1e877db6ecaf7bdbe21de250/src/averagemode.jl#L50-L83">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LossFunctions.AvgMode.WeightedMean" href="#LossFunctions.AvgMode.WeightedMean"><code>LossFunctions.AvgMode.WeightedMean</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">AvgMode.WeightedMean(weights; [normalize = true])</code></pre><p>Causes the method to return the weighted mean of all observations. The variable <code>weights</code> has to be a vector of the same length as the number of observations. If <code>normalize = true</code>, the values of the weight vector will be normalized in such as way that they sum to one.</p><p><strong>Arguments</strong></p><ul><li><code>weights::AbstractVector</code>: Vector of weight values that can be used to give certain observations a stronger influence on the mean.</li></ul><ul><li><p><code>normalize::Bool</code>: Boolean that specifies if the weight vector should be transformed in such a way that it sums to one (i.e. normalized). This will not mutate the weight vector but instead happen on the fly during the accumulation.</p><p>Defaults to <code>true</code>. Setting it to <code>false</code> only really makes sense in multivalue-regression, otherwise the result will be the same as for <a href="#LossFunctions.AvgMode.WeightedSum"><code>WeightedSum</code></a>.</p></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; AvgMode.WeightedMean([1,1,2]); # 3 observations

julia&gt; AvgMode.WeightedMean([1,1,2], normalize = false);</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaML/LossFunctions.jl/blob/64d4c4e16e19698a1e877db6ecaf7bdbe21de250/src/averagemode.jl#L91-L124">source</a></section><h2><a class="nav-anchor" id="Unweighted-Sum-and-Mean-1" href="#Unweighted-Sum-and-Mean-1">Unweighted Sum and Mean</a></h2><p>As hinted before, we provide special memory efficient methods for computing the <strong>sum</strong> or the <strong>mean</strong> of the element-wise (or broadcasted) results of <a href="#LearnBase.value-Tuple{Loss,AbstractArray,AbstractArray,LossFunctions.AverageMode}"><code>value</code></a>, <a href="#LearnBase.deriv-Tuple{Loss,AbstractArray,AbstractArray,LossFunctions.AverageMode}"><code>deriv</code></a>, and <a href="#LearnBase.deriv2-Tuple{Loss,AbstractArray,AbstractArray,LossFunctions.AverageMode}"><code>deriv2</code></a>. These methods avoid the allocation of a temporary array and instead compute the result directly.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LearnBase.value-Tuple{Loss,AbstractArray,AbstractArray,LossFunctions.AverageMode}" href="#LearnBase.value-Tuple{Loss,AbstractArray,AbstractArray,LossFunctions.AverageMode}"><code>LearnBase.value</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">value(loss, target::AbstractArray, output::AbstractArray, avgmode::AverageMode) -&gt; Number</code></pre><p>Compute the weighted or unweighted sum or mean (depending on <code>avgmode</code>) of the individual values of the loss function for each pair in <code>targets</code> and <code>outputs</code>. This method will not allocate a temporary array.</p><p>In the case that the two parameters are arrays with a different number of dimensions, broadcast will be performed. Note that the given parameters are expected to have the same size in the dimensions they share.</p><p>Note: This function should always be type-stable. If it isn&#39;t, you likely found a bug.</p><p><strong>Arguments</strong></p><ul><li><p><code>loss::SupervisedLoss</code>: The loss-function <span>$L$</span> we are working with.</p></li><li><p><code>targets::AbstractArray</code>: The array of ground truths <span>$\mathbf{y}$</span>.</p></li><li><p><code>outputs::AbstractArray</code>: The array of predicted outputs <span>$\mathbf{\hat{y}}$</span>.</p></li><li><p><code>avgmode::AverageMode</code>: Must be one of the following: <a href="#LossFunctions.AvgMode.Sum"><code>AvgMode.Sum()</code></a>, <a href="#LossFunctions.AvgMode.Mean"><code>AvgMode.Mean()</code></a>, <a href="#LossFunctions.AvgMode.WeightedSum"><code>AvgMode.WeightedSum</code></a>, or <a href="#LossFunctions.AvgMode.WeightedMean"><code>AvgMode.WeightedMean</code></a>.</p></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; value(L1DistLoss(), [1,2,3], [2,5,-2], AvgMode.Sum())
9

julia&gt; value(L1DistLoss(), [1.,2,3], [2,5,-2], AvgMode.Sum())
9.0

julia&gt; value(L1DistLoss(), [1,2,3], [2,5,-2], AvgMode.Mean())
3.0

julia&gt; value(L1DistLoss(), Float32[1,2,3], Float32[2,5,-2], AvgMode.Mean())
3.0f0</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaML/LossFunctions.jl/blob/64d4c4e16e19698a1e877db6ecaf7bdbe21de250/src/supervised/supervised.jl#L699-L742">source</a></section><p>The exact same method signature is also implemented for <a href="#LearnBase.deriv-Tuple{Loss,AbstractArray,AbstractArray,LossFunctions.AverageMode}"><code>deriv</code></a> and <a href="#LearnBase.deriv2-Tuple{Loss,AbstractArray,AbstractArray,LossFunctions.AverageMode}"><code>deriv2</code></a> respectively.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LearnBase.deriv-Tuple{Loss,AbstractArray,AbstractArray,LossFunctions.AverageMode}" href="#LearnBase.deriv-Tuple{Loss,AbstractArray,AbstractArray,LossFunctions.AverageMode}"><code>LearnBase.deriv</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">deriv(loss, target::AbstractArray, output::AbstractArray, avgmode::AverageMode) -&gt; Number</code></pre><p>Compute the weighted or unweighted sum or mean (depending on <code>avgmode</code>) of the individual derivatives of the loss function for each pair in <code>targets</code> and <code>outputs</code>. This method will not allocate a temporary array.</p><p>In the case that the two parameters are arrays with a different number of dimensions, broadcast will be performed. Note that the given parameters are expected to have the same size in the dimensions they share.</p><p>Note: This function should always be type-stable. If it isn&#39;t, you likely found a bug.</p><p><strong>Arguments</strong></p><ul><li><p><code>loss::SupervisedLoss</code>: The loss-function <span>$L$</span> we are working with.</p></li><li><p><code>targets::AbstractArray</code>: The array of ground truths <span>$\mathbf{y}$</span>.</p></li><li><p><code>outputs::AbstractArray</code>: The array of predicted outputs <span>$\mathbf{\hat{y}}$</span>.</p></li><li><p><code>avgmode::AverageMode</code>: Must be one of the following: <a href="#LossFunctions.AvgMode.Sum"><code>AvgMode.Sum()</code></a>, <a href="#LossFunctions.AvgMode.Mean"><code>AvgMode.Mean()</code></a>, <a href="#LossFunctions.AvgMode.WeightedSum"><code>AvgMode.WeightedSum</code></a>, or <a href="#LossFunctions.AvgMode.WeightedMean"><code>AvgMode.WeightedMean</code></a>.</p></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; deriv(L2DistLoss(), [1,2,3], [2,5,-2], AvgMode.Sum())
-2

julia&gt; deriv(L2DistLoss(), [1,2,3], [2,5,-2], AvgMode.Mean())
-0.6666666666666666</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaML/LossFunctions.jl/blob/64d4c4e16e19698a1e877db6ecaf7bdbe21de250/src/supervised/supervised.jl#L883-L920">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LearnBase.deriv2-Tuple{Loss,AbstractArray,AbstractArray,LossFunctions.AverageMode}" href="#LearnBase.deriv2-Tuple{Loss,AbstractArray,AbstractArray,LossFunctions.AverageMode}"><code>LearnBase.deriv2</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">deriv2(loss, target::AbstractArray, output::AbstractArray, avgmode::AverageMode) -&gt; Number</code></pre><p>Compute the weighted or unweighted sum or mean (depending on <code>avgmode</code>) of the individual second derivatives of the loss function for each pair in <code>targets</code> and <code>outputs</code>. This method will not allocate a temporary array.</p><p>In the case that the two parameters are arrays with a different number of dimensions, broadcast will be performed. Note that the given parameters are expected to have the same size in the dimensions they share.</p><p>Note: This function should always be type-stable. If it isn&#39;t, you likely found a bug.</p><p><strong>Arguments</strong></p><ul><li><p><code>loss::SupervisedLoss</code>: The loss-function <span>$L$</span> we are working with.</p></li><li><p><code>targets::AbstractArray</code>: The array of ground truths <span>$\mathbf{y}$</span>.</p></li><li><p><code>outputs::AbstractArray</code>: The array of predicted outputs <span>$\mathbf{\hat{y}}$</span>.</p></li><li><p><code>avgmode::AverageMode</code>: Must be one of the following: <a href="#LossFunctions.AvgMode.Sum"><code>AvgMode.Sum()</code></a>, <a href="#LossFunctions.AvgMode.Mean"><code>AvgMode.Mean()</code></a>, <a href="#LossFunctions.AvgMode.WeightedSum"><code>AvgMode.WeightedSum</code></a>, or <a href="#LossFunctions.AvgMode.WeightedMean"><code>AvgMode.WeightedMean</code></a>.</p></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; deriv2(LogitDistLoss(), [1.,2,3], [2,5,-2], AvgMode.Sum())
0.49687329928636825

julia&gt; deriv2(LogitDistLoss(), [1.,2,3], [2,5,-2], AvgMode.Mean())
0.1656244330954561</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaML/LossFunctions.jl/blob/64d4c4e16e19698a1e877db6ecaf7bdbe21de250/src/supervised/supervised.jl#L1055-L1092">source</a></section><h2><a class="nav-anchor" id="Sum-and-Mean-per-Observation-1" href="#Sum-and-Mean-per-Observation-1">Sum and Mean per Observation</a></h2><p>When the targets and predicted outputs are multi-dimensional arrays instead of vectors, we may be interested in accumulating the values over all but one dimension. This is typically the case when we work in a multi-variable regression setting, where each observation has multiple outputs and thus multiple targets. In those scenarios we may be more interested in the average loss for each observation, rather than the total average over all the data.</p><p>To be able to accumulate the values for each observation separately, we have to know and explicitly specify the dimension that denotes the observations. For that purpose we provide the types contained in the namespace <code>ObsDim</code>.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LearnBase.value-Tuple{Loss,AbstractArray,AbstractArray,LossFunctions.AverageMode,LearnBase.ObsDimension}" href="#LearnBase.value-Tuple{Loss,AbstractArray,AbstractArray,LossFunctions.AverageMode,LearnBase.ObsDimension}"><code>LearnBase.value</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">value(loss, target::AbstractArray, output::AbstractArray, avgmode::AverageMode, obsdim::ObsDimension) -&gt; AbstractVector</code></pre><p>Compute the values of the loss function for each pair in <code>targets</code> and <code>outputs</code> individually, and return either the weighted or unweighted sum or mean for each observation (depending on <code>avgmode</code>). This method will not allocate a temporary array, but it will allocate the resulting vector.</p><p>Both arrays have to be of the same shape and size. Furthermore they have to have at least two array dimensions (i.e. they must not be vectors).</p><p>Note: This function should always be type-stable. If it isn&#39;t, you likely found a bug.</p><p><strong>Arguments</strong></p><ul><li><p><code>loss::SupervisedLoss</code>: The loss-function <span>$L$</span> we are working with.</p></li><li><p><code>targets::AbstractArray</code>: The array of ground truths <span>$\mathbf{y}$</span>.</p></li><li><p><code>outputs::AbstractArray</code>: The array of predicted outputs <span>$\mathbf{\hat{y}}$</span>.</p></li><li><p><code>avgmode::AverageMode</code>: Must be one of the following: <a href="#LossFunctions.AvgMode.Sum"><code>AvgMode.Sum()</code></a>, <a href="#LossFunctions.AvgMode.Mean"><code>AvgMode.Mean()</code></a>, <a href="#LossFunctions.AvgMode.WeightedSum"><code>AvgMode.WeightedSum</code></a>, or <a href="#LossFunctions.AvgMode.WeightedMean"><code>AvgMode.WeightedMean</code></a>.</p></li><li><p><code>obsdim::ObsDimension</code>: Specifies which of the array dimensions denotes the observations. see <code>?ObsDim</code> for more information.</p></li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaML/LossFunctions.jl/blob/64d4c4e16e19698a1e877db6ecaf7bdbe21de250/src/supervised/supervised.jl#L746-L776">source</a></section><p>Consider the following two matrices, <code>targets</code> and <code>outputs</code>. We will fill them with some generated example values in order to better understand the effects of later operations.</p><pre><code class="language-julia-repl">julia&gt; targets = reshape(1:8, (2, 4)) ./ 8
2×4 Array{Float64,2}:
 0.125  0.375  0.625  0.875
 0.25   0.5    0.75   1.0

julia&gt; outputs = reshape(1:2:16, (2, 4)) ./ 8
2×4 Array{Float64,2}:
 0.125  0.625  1.125  1.625
 0.375  0.875  1.375  1.875</code></pre><p>There are two ways to interpret the shape of these arrays if one dimension is supposed to denote the observations. The first interpretation would be to say that the first dimension denotes the observations. Thus this data would consist of two observations with four variables each.</p><pre><code class="language-julia-repl">julia&gt; value(L1DistLoss(), targets, outputs, AvgMode.Sum(), ObsDim.First())
2-element Array{Float64,1}:
 1.5
 2.0

julia&gt; value(L1DistLoss(), targets, outputs, AvgMode.Mean(), ObsDim.First())
2-element Array{Float64,1}:
 0.375
 0.5</code></pre><p>The second possible interpretation would be to say that the second/last dimension denotes the observations. In that case our data consists of four observations with two variables each.</p><pre><code class="language-julia-repl">julia&gt; value(L1DistLoss(), targets, outputs, AvgMode.Sum(), ObsDim.Last())
4-element Array{Float64,1}:
 0.125
 0.625
 1.125
 1.625

julia&gt; value(L1DistLoss(), targets, outputs, AvgMode.Mean(), ObsDim.Last())
4-element Array{Float64,1}:
 0.0625
 0.3125
 0.5625
 0.8125</code></pre><p>Because this method returns a vector of values, we also provide a mutating version that can make use a preallocated vector to write the results into.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LearnBase.value!-Tuple{AbstractArray,Loss,AbstractArray,AbstractArray,LossFunctions.AverageMode,LearnBase.ObsDimension}" href="#LearnBase.value!-Tuple{AbstractArray,Loss,AbstractArray,AbstractArray,LossFunctions.AverageMode,LearnBase.ObsDimension}"><code>LearnBase.value!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">value!(buffer::AbstractArray, loss, target::AbstractArray, output::AbstractArray, avgmode::AverageMode, obsdim::ObsDimension) -&gt; buffer</code></pre><p>Compute the values of the loss function for each pair in <code>targets</code> and <code>outputs</code> individually, and return either the weighted or unweighted sum or mean for each observation, depending on <code>avgmode</code>. The results are stored into the given vector <code>buffer</code>. This method will not allocate a temporary array.</p><p>Both arrays have to be of the same shape and size. Furthermore they have to have at least two array dimensions (i.e. so they must not be vectors).</p><p>Note: This function should always be type-stable. If it isn&#39;t, you likely found a bug.</p><p><strong>Arguments</strong></p><ul><li><p><code>buffer::AbstractArray</code>: Array to store the computed values in. Old values will be overwritten and lost.</p></li><li><p><code>loss::SupervisedLoss</code>: The loss-function <span>$L$</span> we are working with.</p></li><li><p><code>targets::AbstractArray</code>: The array of ground truths <span>$\mathbf{y}$</span>.</p></li><li><p><code>outputs::AbstractArray</code>: The array of predicted outputs <span>$\mathbf{\hat{y}}$</span>.</p></li><li><p><code>avgmode::AverageMode</code>: Must be one of the following: <a href="#LossFunctions.AvgMode.Sum"><code>AvgMode.Sum()</code></a>, <a href="#LossFunctions.AvgMode.Mean"><code>AvgMode.Mean()</code></a>, <a href="#LossFunctions.AvgMode.WeightedSum"><code>AvgMode.WeightedSum</code></a>, or <a href="#LossFunctions.AvgMode.WeightedMean"><code>AvgMode.WeightedMean</code></a>.</p></li><li><p><code>obsdim::ObsDimension</code>: Specifies which of the array dimensions denotes the observations. see <code>?ObsDim</code> for more information.</p></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; targets = reshape(1:8, (2, 4)) ./ 8;

julia&gt; outputs = reshape(1:2:16, (2, 4)) ./ 8;

julia&gt; buffer = zeros(2);

julia&gt; value!(buffer, L1DistLoss(), targets, outputs, AvgMode.Sum(), ObsDim.First())
2-element Array{Float64,1}:
 1.5
 2.0

julia&gt; buffer = zeros(4);

julia&gt; value!(buffer, L1DistLoss(), targets, outputs, AvgMode.Sum(), ObsDim.Last())
4-element Array{Float64,1}:
 0.125
 0.625
 1.125
 1.625</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaML/LossFunctions.jl/blob/64d4c4e16e19698a1e877db6ecaf7bdbe21de250/src/supervised/supervised.jl#L780-L837">source</a></section><p>Naturally we also provide both of these methods for <a href="#LearnBase.deriv-Tuple{Loss,AbstractArray,AbstractArray,LossFunctions.AverageMode}"><code>deriv</code></a> and <a href="#LearnBase.deriv2-Tuple{Loss,AbstractArray,AbstractArray,LossFunctions.AverageMode}"><code>deriv2</code></a> respectively.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LearnBase.deriv-Tuple{Loss,AbstractArray,AbstractArray,LossFunctions.AverageMode,LearnBase.ObsDimension}" href="#LearnBase.deriv-Tuple{Loss,AbstractArray,AbstractArray,LossFunctions.AverageMode,LearnBase.ObsDimension}"><code>LearnBase.deriv</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">deriv(loss, target::AbstractArray, output::AbstractArray, avgmode::AverageMode, obsdim::ObsDimension) -&gt; AbstractVector</code></pre><p>Compute the derivative of the loss function for each pair in <code>targets</code> and <code>outputs</code> individually, and return either the weighted or unweighted sum or mean for each observation (depending on <code>avgmode</code>). This method will not allocate a temporary array, but it will allocate the resulting vector.</p><p>Both arrays have to be of the same shape and size. Furthermore they have to have at least two array dimensions (i.e. they must not be vectors).</p><p>Note: This function should always be type-stable. If it isn&#39;t, you likely found a bug.</p><p><strong>Arguments</strong></p><ul><li><p><code>loss::SupervisedLoss</code>: The loss-function <span>$L$</span> we are working with.</p></li><li><p><code>targets::AbstractArray</code>: The array of ground truths <span>$\mathbf{y}$</span>.</p></li><li><p><code>outputs::AbstractArray</code>: The array of predicted outputs <span>$\mathbf{\hat{y}}$</span>.</p></li><li><p><code>avgmode::AverageMode</code>: Must be one of the following: <a href="#LossFunctions.AvgMode.Sum"><code>AvgMode.Sum()</code></a>, <a href="#LossFunctions.AvgMode.Mean"><code>AvgMode.Mean()</code></a>, <a href="#LossFunctions.AvgMode.WeightedSum"><code>AvgMode.WeightedSum</code></a>, or <a href="#LossFunctions.AvgMode.WeightedMean"><code>AvgMode.WeightedMean</code></a>.</p></li><li><p><code>obsdim::ObsDimension</code>: Specifies which of the array dimensions denotes the observations. see <code>?ObsDim</code> for more information.</p></li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaML/LossFunctions.jl/blob/64d4c4e16e19698a1e877db6ecaf7bdbe21de250/src/supervised/supervised.jl#L924-L954">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LearnBase.deriv!-Tuple{AbstractArray,Loss,AbstractArray,AbstractArray,LossFunctions.AverageMode,LearnBase.ObsDimension}" href="#LearnBase.deriv!-Tuple{AbstractArray,Loss,AbstractArray,AbstractArray,LossFunctions.AverageMode,LearnBase.ObsDimension}"><code>LearnBase.deriv!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">deriv!(buffer::AbstractArray, loss, target::AbstractArray, output::AbstractArray, avgmode::AverageMode, obsdim::ObsDimension) -&gt; buffer</code></pre><p>Compute the derivative of the loss function for each pair in <code>targets</code> and <code>outputs</code> individually, and return either the weighted or unweighted sum or mean for each observation, depending on <code>avgmode</code>. The results are stored into the given vector <code>buffer</code>. This method will not allocate a temporary array.</p><p>Both arrays have to be of the same shape and size. Furthermore they have to have at least two array dimensions (i.e. so they must not be vectors).</p><p>Note: This function should always be type-stable. If it isn&#39;t, you likely found a bug.</p><p><strong>Arguments</strong></p><ul><li><p><code>buffer::AbstractArray</code>: Array to store the computed values in. Old values will be overwritten and lost.</p></li><li><p><code>loss::SupervisedLoss</code>: The loss-function <span>$L$</span> we are working with.</p></li><li><p><code>targets::AbstractArray</code>: The array of ground truths <span>$\mathbf{y}$</span>.</p></li><li><p><code>outputs::AbstractArray</code>: The array of predicted outputs <span>$\mathbf{\hat{y}}$</span>.</p></li><li><p><code>avgmode::AverageMode</code>: Must be one of the following: <a href="#LossFunctions.AvgMode.Sum"><code>AvgMode.Sum()</code></a>, <a href="#LossFunctions.AvgMode.Mean"><code>AvgMode.Mean()</code></a>, <a href="#LossFunctions.AvgMode.WeightedSum"><code>AvgMode.WeightedSum</code></a>, or <a href="#LossFunctions.AvgMode.WeightedMean"><code>AvgMode.WeightedMean</code></a>.</p></li><li><p><code>obsdim::ObsDimension</code>: Specifies which of the array dimensions denotes the observations. see <code>?ObsDim</code> for more information.</p></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; targets = reshape(1:8, (2, 4)) ./ 8;

julia&gt; outputs = reshape(1:2:16, (2, 4)) ./ 8;

julia&gt; buffer = zeros(2);

julia&gt; deriv!(buffer, L1DistLoss(), targets, outputs, AvgMode.Sum(), ObsDim.First())
2-element Array{Float64,1}:
 3.0
 4.0

julia&gt; buffer = zeros(4);

julia&gt; deriv!(buffer, L1DistLoss(), targets, outputs, AvgMode.Sum(), ObsDim.Last())
4-element Array{Float64,1}:
 1.0
 2.0
 2.0
 2.0</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaML/LossFunctions.jl/blob/64d4c4e16e19698a1e877db6ecaf7bdbe21de250/src/supervised/supervised.jl#L958-L1015">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LearnBase.deriv2-Tuple{Loss,AbstractArray,AbstractArray,LossFunctions.AverageMode,LearnBase.ObsDimension}" href="#LearnBase.deriv2-Tuple{Loss,AbstractArray,AbstractArray,LossFunctions.AverageMode,LearnBase.ObsDimension}"><code>LearnBase.deriv2</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">deriv2(loss, target::AbstractArray, output::AbstractArray, avgmode::AverageMode, obsdim::ObsDimension) -&gt; AbstractVector</code></pre><p>Compute the second derivative of the loss function for each pair in <code>targets</code> and <code>outputs</code> individually, and return either the weighted or unweighted sum or mean for each observation (depending on <code>avgmode</code>). This method will not allocate a temporary array, but it will allocate the resulting vector.</p><p>Both arrays have to be of the same shape and size. Furthermore they have to have at least two array dimensions (i.e. they must not be vectors).</p><p>Note: This function should always be type-stable. If it isn&#39;t, you likely found a bug.</p><p><strong>Arguments</strong></p><ul><li><p><code>loss::SupervisedLoss</code>: The loss-function <span>$L$</span> we are working with.</p></li><li><p><code>targets::AbstractArray</code>: The array of ground truths <span>$\mathbf{y}$</span>.</p></li><li><p><code>outputs::AbstractArray</code>: The array of predicted outputs <span>$\mathbf{\hat{y}}$</span>.</p></li><li><p><code>avgmode::AverageMode</code>: Must be one of the following: <a href="#LossFunctions.AvgMode.Sum"><code>AvgMode.Sum()</code></a>, <a href="#LossFunctions.AvgMode.Mean"><code>AvgMode.Mean()</code></a>, <a href="#LossFunctions.AvgMode.WeightedSum"><code>AvgMode.WeightedSum</code></a>, or <a href="#LossFunctions.AvgMode.WeightedMean"><code>AvgMode.WeightedMean</code></a>.</p></li><li><p><code>obsdim::ObsDimension</code>: Specifies which of the array dimensions denotes the observations. see <code>?ObsDim</code> for more information.</p></li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaML/LossFunctions.jl/blob/64d4c4e16e19698a1e877db6ecaf7bdbe21de250/src/supervised/supervised.jl#L1096-L1126">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LossFunctions.deriv2!-Tuple{AbstractArray,Loss,AbstractArray,AbstractArray,LossFunctions.AverageMode,LearnBase.ObsDimension}" href="#LossFunctions.deriv2!-Tuple{AbstractArray,Loss,AbstractArray,AbstractArray,LossFunctions.AverageMode,LearnBase.ObsDimension}"><code>LossFunctions.deriv2!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">deriv2!(buffer::AbstractArray, loss, target::AbstractArray, output::AbstractArray, avgmode::AverageMode, obsdim::ObsDimension) -&gt; buffer</code></pre><p>Compute the second derivative of the loss function for each pair in <code>targets</code> and <code>outputs</code> individually, and return either the weighted or unweighted sum or mean for each observation, depending on <code>avgmode</code>. The results are stored into the given vector <code>buffer</code>. This method will not allocate a temporary array.</p><p>Both arrays have to be of the same shape and size. Furthermore they have to have at least two array dimensions (i.e. so they must not be vectors).</p><p>Note: This function should always be type-stable. If it isn&#39;t, you likely found a bug.</p><p><strong>Arguments</strong></p><ul><li><p><code>buffer::AbstractArray</code>: Array to store the computed values in. Old values will be overwritten and lost.</p></li><li><p><code>loss::SupervisedLoss</code>: The loss-function <span>$L$</span> we are working with.</p></li><li><p><code>targets::AbstractArray</code>: The array of ground truths <span>$\mathbf{y}$</span>.</p></li><li><p><code>outputs::AbstractArray</code>: The array of predicted outputs <span>$\mathbf{\hat{y}}$</span>.</p></li><li><p><code>avgmode::AverageMode</code>: Must be one of the following: <a href="#LossFunctions.AvgMode.Sum"><code>AvgMode.Sum()</code></a>, <a href="#LossFunctions.AvgMode.Mean"><code>AvgMode.Mean()</code></a>, <a href="#LossFunctions.AvgMode.WeightedSum"><code>AvgMode.WeightedSum</code></a>, or <a href="#LossFunctions.AvgMode.WeightedMean"><code>AvgMode.WeightedMean</code></a>.</p></li><li><p><code>obsdim::ObsDimension</code>: Specifies which of the array dimensions denotes the observations. see <code>?ObsDim</code> for more information.</p></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; targets = reshape(1:8, (2, 4)) ./ 8;

julia&gt; outputs = reshape(1:2:16, (2, 4)) ./ 8;

julia&gt; buffer = zeros(2);

julia&gt; deriv2!(buffer, L2DistLoss(), targets, outputs, AvgMode.Sum(), ObsDim.First())
2-element Array{Float64,1}:
 8.0
 8.0

julia&gt; buffer = zeros(4);

julia&gt; deriv2!(buffer, L2DistLoss(), targets, outputs, AvgMode.Sum(), ObsDim.Last())
4-element Array{Float64,1}:
 4.0
 4.0
 4.0
 4.0</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaML/LossFunctions.jl/blob/64d4c4e16e19698a1e877db6ecaf7bdbe21de250/src/supervised/supervised.jl#L1130-L1187">source</a></section><h2><a class="nav-anchor" id="Weighted-Sum-and-Mean-1" href="#Weighted-Sum-and-Mean-1">Weighted Sum and Mean</a></h2><p>Up to this point, all the averaging was performed in an unweighted manner. That means that each observation was treated as equal and had thus the same potential influence on the result. In this sub-section we will consider the situations in which we do want to explicitly specify the influence of each observation (i.e. we want to weigh them). When we say we &quot;weigh&quot; an observation, what it effectively boils down to is multiplying the result for that observation (i.e. the computed loss or derivative) with some number. This is done for every observation individually.</p><p>To get a better understand of what we are talking about, let us consider performing a weighting scheme manually. The following code will compute the loss for three observations, and then multiply the result of the second observation with the number <code>2</code>, while the other two remains as they are. If we then sum up the results, we will see that the loss of the second observation was effectively counted twice.</p><pre><code class="language-julia-repl">julia&gt; result = value.(L1DistLoss(), [1.,2,3], [2,5,-2]) .* [1,2,1]
3-element Array{Float64,1}:
 1.0
 6.0
 5.0

julia&gt; sum(result)
12.0</code></pre><p>The point of weighing observations is to inform the learning algorithm we are working with, that it is more important to us to predict some observations correctly than it is for others. So really, the concrete weight-factor matters less than the ratio between the different weights. In the example above the second observation was thus considered twice as important as any of the other two observations.</p><p>In the case of multi-dimensional arrays the process isn&#39;t that simple anymore. In such a scenario, computing the weighted sum (or weighted mean) can be thought of as having an additional step. First we either compute the sum or (unweighted) average for each observation (which results in a vector), and then we compute the weighted sum of all observations.</p><p>The following code snipped demonstrates how to compute the <code>AvgMode.WeightedSum([2,1])</code> manually. This is <strong>not</strong> meant as an example of how to do it, but simply to show what is happening qualitatively. In this example we assume that we are working in a multi-variable regression setting, in which our data set has four observations with two target-variables each.</p><pre><code class="language-julia-repl">julia&gt; targets = reshape(1:8, (2, 4)) ./ 8
2×4 Array{Float64,2}:
 0.125  0.375  0.625  0.875
 0.25   0.5    0.75   1.0

julia&gt; outputs = reshape(1:2:16, (2, 4)) ./ 8
2×4 Array{Float64,2}:
 0.125  0.625  1.125  1.625
 0.375  0.875  1.375  1.875

julia&gt; # WARNING: BAD CODE - ONLY FOR ILLUSTRATION

julia&gt; tmp = sum(value.(L1DistLoss(), targets, outputs), dims=2) # assuming ObsDim.First()
2×1 Array{Float64,2}:
 1.5
 2.0

julia&gt; sum(tmp .* [2, 1]) # weigh 1st observation twice as high
5.0</code></pre><p>To manually compute the result for <code>AvgMode.WeightedMean([2,1])</code> we follow a similar approach, but use the normalized weight vector in the last step.</p><pre><code class="language-julia-repl">julia&gt; using Statistics # for access to &quot;mean&quot;

julia&gt; # WARNING: BAD CODE - ONLY FOR ILLUSTRATION

julia&gt; tmp = mean(value.(L1DistLoss(), targets, outputs), dims=2) # ObsDim.First()
2×1 Array{Float64,2}:
 0.375
 0.5

julia&gt; sum(tmp .* [0.6666, 0.3333]) # weigh 1st observation twice as high
0.416625</code></pre><p>Note that you can specify explicitly if you want to normalize the weight vector. That option is supported for computing the weighted sum, as well as for computing the weighted mean. See the documentation for <a href="#LossFunctions.AvgMode.WeightedSum"><code>AvgMode.WeightedSum</code></a> and <a href="#LossFunctions.AvgMode.WeightedMean"><code>AvgMode.WeightedMean</code></a> for more information.</p><p>The code-snippets above are of course very inefficient, because they allocate (multiple) temporary arrays. We only included them to demonstrate what is happening in terms of desired result / effect. For doing those computations efficiently we provide special methods for <a href="#LearnBase.value-Tuple{Loss,AbstractArray,AbstractArray,LossFunctions.AverageMode}"><code>value</code></a>, <a href="#LearnBase.deriv-Tuple{Loss,AbstractArray,AbstractArray,LossFunctions.AverageMode}"><code>deriv</code></a>, <a href="#LearnBase.deriv2-Tuple{Loss,AbstractArray,AbstractArray,LossFunctions.AverageMode}"><code>deriv2</code></a> and their mutating counterparts.</p><pre><code class="language-julia-repl">julia&gt; value(L1DistLoss(), [1.,2,3], [2,5,-2], AvgMode.WeightedSum([1,2,1]))
12.0

julia&gt; value(L1DistLoss(), [1.,2,3], [2,5,-2], AvgMode.WeightedMean([1,2,1]))
3.0

julia&gt; value(L1DistLoss(), targets, outputs, AvgMode.WeightedSum([2,1]), ObsDim.First())
5.0

julia&gt; value(L1DistLoss(), targets, outputs, AvgMode.WeightedMean([2,1]), ObsDim.First())
0.4166666666666667</code></pre><p>We also provide this functionality for <a href="#LearnBase.deriv-Tuple{Loss,AbstractArray,AbstractArray,LossFunctions.AverageMode}"><code>deriv</code></a> and <a href="#LearnBase.deriv2-Tuple{Loss,AbstractArray,AbstractArray,LossFunctions.AverageMode}"><code>deriv2</code></a> respectively.</p><pre><code class="language-julia-repl">julia&gt; deriv(L2DistLoss(), [1.,2,3], [2,5,-2], AvgMode.WeightedSum([1,2,1]))
4.0

julia&gt; deriv(L2DistLoss(), [1.,2,3], [2,5,-2], AvgMode.WeightedMean([1,2,1]))
1.0

julia&gt; deriv(L2DistLoss(), targets, outputs, AvgMode.WeightedSum([2,1]), ObsDim.First())
10.0

julia&gt; deriv(L2DistLoss(), targets, outputs, AvgMode.WeightedMean([2,1]), ObsDim.First())
0.8333333333333334</code></pre><footer><hr/><a class="previous" href="../interface/"><span class="direction">Previous</span><span class="title">Working with Losses</span></a><a class="next" href="../../losses/distance/"><span class="direction">Next</span><span class="title">Distance-based Losses</span></a></footer></article></body></html>
